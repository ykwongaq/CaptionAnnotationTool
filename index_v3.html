<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/FileSaver.js/2014-11-29/FileSaver.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">
    <style>
        input:checked + label {
            border-color: black;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            font-weight: bold;
        }
        .reminder {
            background-color: #ffcc00; /* Background color */
            padding: 20px; /* Padding for aesthetics */
            border: 2px solid #000; /* Border for visibility */
            z-index: 1000; /* Ensure it's on top of other elements */
            text-align: center; /* Center the text */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Shadow for a "pop" effect */
            font-size: 20px; /* Larger font size for visibility */
        }
        .top-button {
            z-index: 1000;
        }

        /* .negative_tags_dict {
            display: inline-flex;
            align-items: center;
        } */

        .negative_tags_dict div {
            display: inline-flex;
            flex-wrap: wrap;
            margin-top: 0.5rem;
            /* justify-content: center; */
        }

        .negative_tags_dict input[type="checkbox"] {
            display: none;
        }

        .negative_tags_dict input[type="checkbox"]:checked + span {
            box-shadow: 0 0 0 0.0625em #0043ed;
            background-color: #dee7ff;
            z-index: 1;
            color: #0043ed;
        }

        .negative_tags:focus {
            outline: 0;
            border-color: #2260ff;
            box-shadow: 0 0 0 4px #b5c9fc;
        }

        .negative_tags label span {
            display: block;
            cursor: pointer;
            background-color: #fff;
            padding: 0.375em .75em;
            position: relative;
            margin-left: .0625em;
            box-shadow: 0 0 0 0.0625em #b5bfd9;
            letter-spacing: .05em;
            color: #3e4963;
            text-align: center;
            transition: background-color .5s ease;
        }

        .negative_tags label:first-child span {
            border-radius: .375em 0 0 .375em;
        }

        .negative_tags label:last-child span {
            border-radius: 0 .375em .375em 0;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: black;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            
            /* Position the tooltip */
            position: absolute;
            z-index: 1;
            bottom: 100%;
            left: 50%;
            margin-left: -60px;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
        }
    </style>
</head>
<body>
    <div class="bg-white py-12">
        <div class="mx-auto max-w-7xl px-2">
            <div class="mx-auto max-w-2xl sm:text-center">
                <h2 class="text-3xl font-bold tracking-tight text-gray-900 sm:text-4xl">Text Label</h2>
            </div>
            <div style="width: 80%;" class="mx-auto max-w-2xl sm:text-center m-5" id="uploadFileContainer">
                <label class="flex justify-center w-full h-32 px-4 transition bg-white border-2 border-gray-300 border-dashed rounded-md appearance-none cursor-pointer hover:border-gray-400 focus:outline-none" id="drop">
                    <span class="flex items-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                        </svg>
                        <span class="font-medium text-gray-600"><span class="text-blue-600 underline ml-[4px]">browse</span></span>
                        <span></span>
                        <span class="font-medium text-gray-600">Upload the Data Json File!</span>
                    </span>
                    <input type="file" name="file_upload" class="hidden" id="file-input">
                </label>
            </div>

            <div class=" flex justify-between mx-auto max-w-3xl sm:mt-6 lg:mx-0 lg:flex lg:max-w-none">

                <div id="imgContainer" class="relative rounded-sm ring-1 ring-gray-200 sm:text-center max-width:100% overflow:hidden" style="width: 60%; height: 550px;">
                    <img id="img" style="display: block; height: 100%; width: 100%;" src="">
                    <div id="bbox" class="absolute border-2 border-red-400"></div>
                    <div id="imgName" class="mt-1 py-2 text-center text-gray-500  sm:mt-0 sm:text-center"></div>
                </div>

                <div class=" p-7" style="width: 40%;">

                    <div class="flex flex-row">
                        <div class="flex flex-col justify-between sm:text-center ">
                            <div class="font-semibold text-gray-900">Mask</div>
                            <div id="maskIndex" class="mt-1 py-2 text-center text-gray-500  sm:mt-0 sm:text-center">0 / 0</div>              
                        </div>
                        <div class="flex flex-col justify-between sm:text-center ml-10">
                            <div class="font-semibold text-gray-900">Image</div>
                            <div id="imageIndex" class="mt-1 py-2 text-center text-gray-500  sm:mt-0 sm:text-center">0 / 0</div>              
                        </div>
                        <div class="flex flex-col justify-between sm:text-center ml-10">
                            <div class="font-semibold text-gray-900" id="category_count_label">Category: </div>
                            <div id="category_count_index" class="mt-1 py-2 text-center text-gray-500  sm:mt-0 sm:text-center">0 / 0</div>              
                        </div>
                    </div>

                    
                    <div class="flex flex-col">
                        <div class="flex flex-row justify-between sm:text-center">
                            <button onclick="handlePreviousMask()" type="button" class="top-button text-center text-sm border-2 border-black rounded-md shadow-yellow py-2 px-2  hover:bg-gray-700 hover:text-white focus:outline-none bg-yellow">PrevMask</button>
                            <button onclick="handleToggleBbox()" type="button" class="top-button text-center text-sm border-2 border-black rounded-md shadow-yellow py-2 px-2  hover:bg-gray-700 hover:text-white focus:outline-none bg-yellow">Toggle</button>
                            <button onclick="handleNextMask()" type="button" class="top-button bg-bg text-center text-sm border-2 border-black rounded-md shadow-yellow py-2 px-2  hover:bg-gray-700 hover:text-white focus:outline-none bg-yellow">NextMask</button>                
                        </div>
                    </div>

                    <div class="flex flex-col">
                        <dt class="mt-4 font-semibold text-gray-900">Category</dt>
                        <div class="col-span-full">
                            <div class="mt-2">
                                <textarea id="category" rows="2" class="px-2 block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 sm:text-sm sm:leading-6" style="resize:none; overflow:scroll"></textarea>
                            </div>                 
                        </div>
                    </div>
              
                    <div class="flex flex-col">
                        <dt class="mt-4 font-semibold text-gray-900">Caption</dt>
                        <!-- <dd class="mt-2 leading-7 text-gray-400">Non laboris consequat cupidatat laborum magna. Eiusmod non irure cupidatat duis commodo amet.</dd> -->
                        <div class="col-span-full">
                            <div class="mt-2">
                              <textarea id="caption" rows="5" class="px-2 block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 sm:text-sm sm:leading-6" style="resize:none; overflow:scroll"></textarea>
                            </div>
                        </div>
                    </div>

                    <div class="flex items-center justify-center m-5">
                        <form class="grid grid-cols-3 gap-2 w-full max-w-screen-sm">
                            <div>
                                <input class="hidden" id="radio_refined" type="radio" name="annotation_label" value="refined">
                                <label class="flex flex-col p-4 border-2 border-gray-200 rounded-md cursor-pointer" for="radio_refined">
                                    <span class="text-xs font-semibold uppercase">Refined Positive</span>
                                </label>
                            </div>
                            <div>
                                <input class="hidden" id="radio_pos" type="radio" name="annotation_label" value="pos">
                                <label class="flex flex-col p-4 border-2 border-gray-200 rounded-md cursor-pointer" for="radio_pos">
                                    <span class="text-xs font-semibold uppercase">Generated Positive</span>
                                </label>
                            </div>
                            <div>
                                <input class="hidden" id="radio_neg" type="radio" name="annotation_label" value="neg">
                                <label class="flex flex-col p-4 border-2 border-gray-200 rounded-md cursor-pointer" for="radio_neg">
                                    <span class="text-xs font-semibold uppercase">Generated Negative</span>
                                </label>
                            </div>
                        </form>
                    </div>

                    <div class="negative_tags_dict">
                        <label><strong>Object: </strong></label>
                        <div class="negative_tags">
                            <label class="tooltip">
                                <!-- Note that the id has to be the same as the constant value in javascript with "_checkbox" postfix -->
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Classification_checkbox">
                                <span>Classification</span>
                                <span class="tooltiptext">Classify the target wrongly. E.g. Cat is identified as a dog</span>
                            </label>
                            <label class="tooltip">
                                <!-- Note that the id has to be the same as the constant value in javascript with "_checkbox" postfix -->
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Background_checkbox">
                                <span>Background</span>
                                <span class="tooltiptext">Background is identified wrongly. E.g. Ocean is identified as sky</span>
                            </label>
                            <label class="tooltip">
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Unexisting_checkbox">
                                <span>Unexisting</span>
                                <span class="tooltiptext">The object does not exist in the image. E.g. ... with a big black spot ... (but there are not black spot)</span>
                            </label>
                        </div>
                    </div>
                    <div class="negative_tags_dict">
                        <label><strong>Relation: </strong></label>
                        <div class="negative_tags">
                            <label class="tooltip">
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Spatial_checkbox">
                                <span>Spatial</span>
                                <span class="tooltiptext">The spatial relation is wrong. E.g. The fish is swimming to the rigth (but it is to the left)</span>
                            </label>
                            <label class="tooltip">
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Action_checkbox">
                                <span>Action</span>
                                <span class="tooltiptext">The action is wrong. E.g. The fish is eating (but the fish is swimming)</span>
                            </label>
                        </div>
                    </div>
                    <div class="negative_tags_dict">
                        <label><strong>Attribute: </strong></label>
                        <div class="negative_tags">
                            <label class="tooltip">
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Size_checkbox">
                                <span>Size</span>
                                <span class="tooltiptext">The size is wrong. E.g. The fish is big (but the fish is small)</span>
                            </label>
                            <label class="tooltip">
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Color_checkbox">
                                <span>Color</span>
                                <span class="tooltiptext">The color is wrong. E.g. The fish is red (but the fish is blue)</span>
                            </label>
                            <label class="tooltip">
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Shape_checkbox">
                                <span>Shape</span>
                                <span class="tooltiptext">The shape is wrong. E.g. The fish is short (but the fish is long)</span>
                            </label>
                            <label class="tooltip">
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Texture_checkbox">
                                <span>Texture</span>
                                <span class="tooltiptext">The texture is wrong. E.g. The fish is smooth (but the fish is rough)</span>
                            </label>
                            <label class="tooltip">
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Material_checkbox">
                                <span>Material</span>
                                <span class="tooltiptext">The material is wrong. E.g. The fish model is made of wood (but it is made of plastic)</span>
                            </label>
                            <label class="tooltip">
                                <input class="negative_tag_input" type="checkbox" name="radio" id="Counting_checkbox">
                                <span>Counting</span>
                                <span class="tooltiptext">The counting is wrong. E.g. There are 3 fish (but there are 4 fish)</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="flex items-center justify-between mt-5 border-t border-gray-200 bg-white px-4 py-5 sm:px-6">
            <button onclick="handlePrevious()" type="button" class="top-button bg-bg font-bold text-center text-sm border-2 border-black rounded-md shadow-yellow py-2 px-2  hover:bg-gray-700 hover:text-white focus:outline-none bg-yellow">Previous</button>
            <button onclick="saveJsonFile()" type="button" class="top-button bg-bg font-bold text-center text-sm border-2 border-black rounded-md shadow-yellow py-2 px-2  hover:bg-gray-700 hover:text-white focus:outline-none bg-yellow">SaveAndExport</button>
            <button onclick="handleContinue()" type="button" class="top-button bg-bg font-bold text-center text-sm border-2 border-black rounded-md shadow-yellow py-2 px-2  hover:bg-gray-700 hover:text-white focus:outline-none bg-yellow">Continue</button>
            <!-- <button onclick="handleTest()" type="button" class="bg-bg font-bold text-center text-sm border-2 border-black rounded-md shadow-yellow py-2 px-2  hover:bg-gray-700 hover:text-white focus:outline-none bg-yellow">Test</button> -->
            <button onclick="handleNext()" type="button" class="top-button bg-bg font-bold text-center text-sm border-2 border-black rounded-md shadow-yellow py-2 px-2  hover:bg-gray-700 hover:text-white focus:outline-none bg-yellow">Next</button>
        </div>
        <div class="reminder">
            <p>Remember to save the result before leaving!</p>
        </div>
        <div>
            <dialog id="notificationDialog" class="mx-auto max-w-2xl sm:text-center m-2 p-5 border-2 border-black rounded-md" style="top:50%" close>
                <p id="notificationMessage" class="m-2 p-5 text-sm  font-semibold text-gray-900"></p>
                <div class="divide-y divide-dashed"></div>
                <button onclick="closeDialog()" class="bg-bg font-bold text-center border-2 border-black rounded-md shadow-yellow py-2 px-2  hover:bg-gray-700 hover:text-white focus:outline-none bg-yellow">Confirm</button>
            </dialog>
        </div>
    </div>

    <script>
        "strict mode";

        /**
         * Caption is correct
         */
        const POSITIVE = 0;

        /**
         * Caption is incorrect
         */
        const NEGATIVE = 1;

        /**
         * Caption is refined
         */
        const REFINED = 2;

        /**
         * Caption is not labelled
         */
        const NOT_LABELLED = -1;
        

        // Dom elements
        const IMG = document.getElementById("img");
        const IMG_CONTAINER = document.getElementById("imgContainer");
        const IMG_NAME = document.getElementById("imgName");
        const MASK_IDX = document.getElementById("maskIndex");
        const IMAGE_IDX = document.getElementById("imageIndex");
        const CATEGORY = document.getElementById("category");
        const CAPTION = document.getElementById("caption");
        const RADIO_REFINED = document.getElementById("radio_refined");
        const RADIO_POS = document.getElementById("radio_pos");
        const RADIO_NEG = document.getElementById("radio_neg");
        const BBOX = document.getElementById("bbox");
        const NOTIFICATION_DIALOG = document.getElementById("notificationDialog");
        const NOTIFICATION_MESSAGE = document.getElementById("notificationMessage");

        // It is used to keep check of how many category have been refined
        const CATEGORY_COUNT_LABEL = document.getElementById("category_count_label");
        const CATEGORY_COUNT_IDX = document.getElementById("category_count_index");

        // Expected number of reinfed image for each category
        const EXPECTED_REFINED_COUNT = 10
        
        var showLabel = true;

        // Json key for negative tags
        const NEGATIVE_TAGS_PROPERTY = "negative_tags";
        // Negative tags, which will be stored as comma separated string
        const CALSSIFICATION = "Classification";
        const BACKGROUND = "Background"
        const UNEXISTING = "Unexisting"
        const SPATIAL = "Spatial"
        const ACTION = "Action"
        const SIZE = "Size"
        const COLOR = "Color"
        const SHAPE = "Shape"
        const TEXTURE = "Texture"
        const MATERIAL = "Material"
        const COUNTING = "Counting"
        
        const NEGATIVE_TAGS = [CALSSIFICATION, BACKGROUND, UNEXISTING, SPATIAL, ACTION, SIZE, COLOR, SHAPE, TEXTURE, MATERIAL, COUNTING];

        /*
         *  Initialization
         */
        attachNegativeTagOnClick();
        RADIO_POS.onclick = function() {
            clearNegativeTags();
        }
        RADIO_REFINED.onclick = function() {
            clearNegativeTags();
        }


        /**
         * Annotation store the data of an annotation.
         */
        class Annotation {
            /**
             * Constructor
             * @param {JSON} annoData
             */
            constructor(annoData) {
                this.jsonData = annoData;
                this.jsonData.category = this.processCategory(this.jsonData.category);
                if (!this.jsonData.hasOwnProperty("label")) {
                    this.jsonData.label = NOT_LABELLED;
                }
                if (!this.jsonData.hasOwnProperty(NEGATIVE_TAGS_PROPERTY)) {
                    this.jsonData[NEGATIVE_TAGS_PROPERTY] = "";
                }
            }

            /**
             * Get bounding box of the annotation. [x, y, width, height] in term of pixels.
             * @returns {Array} The list of points of the annotation.
             */
            getBbox() {
                return this.jsonData.bbox;
            }

            /**
             * Get the id of the image that the annotation belongs to.
             * @returns {number} The id of the image.
             
            */
            getImageId() {
                return this.jsonData.image_id;
            }

            /**
             * Get the id of the annotation.
             */
            getId() {
                return this.jsonData.id;
            }

            /**
             * Get the caption of the annotation.
             * @returns {string} The caption of the annotation.
             */
            getCaption() {
                return this.jsonData.caption;
            }

            /**
             * Set a new caption for annotaiton
             * @param {string} caption
             */
            setCaption(caption) {
                this.jsonData.caption = caption;
            }

            /**
             * Get the label of the annotation.
             * @returns {number} The label of the annotation.
             */
            getLabel() {
                return this.jsonData.label;
            }

            /**
             * Set the label of the annotation.
             * @param {number} label
             */
            setLabel(label) {
                this.jsonData.label = label;
            }

            /**
             * Get the category of the annotation.
             * @returns {string} The category of the annotation.
             */
            getCategory() {
                return this.jsonData.category;
            }

            /**
             * Get the negative tags of the annotation.
             */
            getNegativeTagsString() {
                return this.jsonData[NEGATIVE_TAGS_PROPERTY];
            }

            /**
             * Set the negative tags of the annotation.
             * @param {string} negative_tags
             */
            setNegativeTagsString(negative_tags) {
                if (Array.isArray(negative_tags) && negative_tags.every(tag => typeof tag === "string")) {
                    negative_tags = negative_tags.join(", ");
                }
                this.jsonData[NEGATIVE_TAGS_PROPERTY] = negative_tags;
            }

            /**
             * Post-processing the catogray data to make it more readable.
             * @param {string} category
             * @returns {string} The processed category.
             */
            processCategory(category) {
                // Find the index of first uppercase letter
                const idx = category.search(/[A-Z]/);
                if (idx === -1) {
                    const words = category.split(" ");
                    const first_word = words[0];

                    let duplicateIndx = -1;
                    for (let i=1; i<words.length; i++) {
                        if (words[i] === first_word) {
                            duplicateIndx = i;
                            // Join the words up to the first occurrence of the first word
                            category = words.slice(0, duplicateIndx).join(" ");
                            break;
                        }
                    }

                    if (duplicateIndx === -1) {
                        if (category.endsWith(".jpg") || 
                            category.endsWith(".png") || 
                            category.endsWith(".jpeg") || 
                            category.endsWith(".PNG") || 
                            category.endsWith(".JPG")) {
                            words.pop()
                            category = words.join(" ");
                            return category;
                        } else {
                            return category;
                        }
                    } else {
                        // Keep the part before first uppercase letter.
                        return category.slice(0, idx);
                    }
                } else {
                    // If there are uppercase letter, just keep the part after the first uppercase letter.
                    return category.slice(0, idx);
                }
            }
        }

        /**
         * It is the name of folder that store the data.
         */
        const DATA_FOLDER = "data";

        /**
         * Image store the data of an image.
         */
        class Image {
            /**
             * Constructor
             * @param {JSON} imageData
             * @param {JSON} annoDatas
             */
            constructor(imageData, annoDatas) {
                this.jsonData = imageData;
                let id = this.jsonData.id;
                this.annotations = [];
                for (const annoData of annoDatas) {
                    console.assert(
                        annoData.image_id === id,
                        "Annotation does not belong to image. Annotation ID: " +
                            annoData.id +
                            ", Image ID: " +
                            id
                    );
                    this.annotations.push(new Annotation(annoData));
                }
            }

            /**
             * Get the id of the image.
             * @returns {number} The id of the image.
             */
            getId() {
                return this.jsonData.id;
            }

            /**
             * Relative path to the image.
             * @returns {string} The path of the image.
             */
            getPath() {
                return `${DATA_FOLDER}/${this.getFileName()}`;
            }

            /**
             * Get the filename of the image.
             * @returns {string} The name of the image file.
             */
            getFileName() {
                return this.jsonData.file_name;
            }

            /**
             * Get annotation list
             * @returns {Array} The list of annotations of the image.
             */
            getAnnotations() {
                return this.annotations;
            }

            /**
             * Count how many annotation in this image.
             * @returns {number} The number of annotations of the image.
             */
            getAnnotationsCount() {
                return this.annotations.length;
            }

            /**
             * Get the width of the image
             * @returns {number} The width of the image.
             */
            getWidth() {
                return this.jsonData.width;
            }

            /**
             * Get the height of the image
             * @returns {number} The height of the image.
             */
            getHeight() {
                return this.jsonData.height;
            }

            /**
             * Get the index of the annotation in the image. (The i-th annotation in this image)
             * @param {Annotation} annotation
             * @returns {number} The index of the annotation in the image.
             */
            getAnnotationIdx(annotation) {
                return this.annotations.indexOf(annotation);
            }

            /**
             * Check if the annotation is the last annotation of the image.
             * @param {Annotation} annotation
             * @returns {boolean} True if the annotation is the last annotation of the image.
             */
            isLastAnnotation(annotation) {
                return this.annotations[this.annotations.length - 1] === annotation;
            }

            /**
             * Get the first annotaiton in this image.
             * @returns {Annotation} The first annotation of the image.
             */
            getFirstAnnotation() {
                return this.annotations[0];
            }

            /**
             * Get the last annotation in this image.
             * @returns {Annotation} The last annotation of the image.
             */
            getLastAnnotation() {
                return this.annotations[this.annotations.length - 1];
            }
        }

        
        /**
         * Dataset store a list of images loaded from json file.
         * It is in singleton pattern.
         */
        class Dataset {
            /**
             * Constructor
             */
            constructor() {
                this.images = [];
            }

            /**
             * Get the singleton instance of the dataset.
             * @returns {Dataset} The instance of the dataset.
             */
            static getInstance() {
                if (!this.instance) {
                    this.instance = new Dataset();
                }
                return this.instance;
            }

            /**
             * Convert json string to dataset object.
             * @param {string} json The json string that contains the data of the dataset.
             */
            parseJson(json) {
                const jsonData = JSON.parse(json);
                const annoDatas = jsonData.annotations;
                for (const imageJson of jsonData.images) {
                    const relatedAnnotations = annoDatas.filter(
                        (annoData) => annoData.image_id === imageJson.id
                    );
                    this.images.push(new Image(imageJson, relatedAnnotations));
                }
                this.categoriesData = jsonData.categories;
            }

            /**
             * Get the image by its id.
             * @param {number} annoId
             * @returns {Image} The image object. Or else return null.
             */
            getImageByAnnotationId(annoId) {
                for (const image of this.images) {
                    for (const anno of image.annotations) {
                        if (anno.getId() === annoId) {
                            return image;
                        }
                    }
                }
                return null;
            }

            /**
             * Get the image that contains the annotation.
             * @param {Annotation} annotation
             * @returns {Image} The image object. Or else return null.
             */
            getImageByAnnotation(annotation) {
                return this.getImageByAnnotationId(annotation.getId());
            }

            /**
             * Get the list of image
             * @returns {Array} The list of images.
             */
            getImages() {
                return this.images;
            }

            /**
             * Count the number of images
             * @returns {number} The number of images.
             */
            getImageCount() {
                this.images.length;
            }

            /**
             * Get the first image of the dataset.
             * @returns {Image} The first image of the dataset.
             */
            getFirstImage() {
                return this.images[0];
            }

            /**
             * Get the last image of the dataset.
             * @returns {Image} The last image of the dataset.
             * */
            getLastImage() {
                return this.images[this.images.length - 1];
            }

            /**
             * Get the index of the image in list.
             * @param {Image} image
             * @returns {number} The index of the image in the dataset.
             */
            getImageIdx(image) {
                return this.images.indexOf(image);
            }

            /**
             * Get the next annotation based on the input annotation.
             * If there are more annotations in the image, return the next one. (case 1)
             * If there are no more annotations in the image, return the first annotation of the next image. (case 2)
             * If there is no more image and annotation, return null. (case 3)
             * @param {Annotation} annotation The input annotation.
             * @returns {Annotation} The next annotation of the input annotation.
             */
            getNextAnnotation(annotation) {
                const image = this.getImageByAnnotation(annotation);
                const idx = image.annotations.indexOf(annotation);

                // Case 1
                if (!image.isLastAnnotation(annotation)) {
                    return image.annotations[idx + 1];
                }

                const imageIdx = this.images.indexOf(image);
                if (imageIdx < this.images.length - 1) {
                    // Case 2
                    return this.images[imageIdx + 1].annotations[0];
                }

                // Case 3
                return null;
            }

            /**
             * Get previous annotation based on the input annotation.
             * If there are previous annotations in the image, return the previous one. (case 1)
             * If there are no previous annotations in the image, return the last annotation of the previous image. (case 2)
             * If there is no more image and annotation, return null. (case 3)
             * @param {Anntoation} annotation
             * @returns {Annotation} The previous annotation of the input annotation.
             */
            getPrevAnnotation(annotation) {
                const image = this.getImageByAnnotation(annotation);
                const idx = image.annotations.indexOf(annotation);
                // Case 1
                if (idx > 0) {
                    return image.annotations[idx - 1];
                }

                const imageIdx = this.getImageIdx(image);
                if (imageIdx > 0) {
                    // Case 2
                    return this.images[imageIdx - 1].getLastAnnotation();
                }

                // Case 3
                return null;
            }

            /**
             * Get the next image based on the given image or annotation.
             * @param {Image || Annotation} input Input can be either an image or an annotation.
             * @returns {Image} The next image of the input.
             */
            getNextImage(input) {
                if (input instanceof Image) {
                    return this.getNextImageByImage(input);
                } else if (input instanceof Annotation) {
                    return this.getNextImageByAnnotation(input);
                } else {
                    throw new Error("Input must be either an image or an annotation.");
                }
            }

            /**
             * Get the previous image based on the given image or annotation.
             * @param {Image || Annotation} input Input can be either an image or an annotation.
             * @returns {Image} The previous image of the input.
             */
            getPrevImage(input) {
                if (input instanceof Image) {
                    return this.getPrevImageByImage(input);
                } else if (input instanceof Annotation) {
                    return this.getPrevImageByAnnotation(input);
                } else {
                    throw new Error("Input must be either an image or an annotation.");
                }
            }

            /**
             * Get the next image based on the given image.
             * If there are more image, return this next one. (case 1)
             * If there are no more image, return null. (case 2)
             * @param {Image} image Input image.
             * @returns {Image} The next image of the input image.
             */
            getNextImageByImage(image) {
                const idx = this.getImageIdx(image);
                if (idx < this.images.length - 1) {
                    return this.images[idx + 1];
                }
                return null;
            }

            /**
             * Get the previous image based on the given image.
             * If there are previous image, return this previous one. (case 1)
             * If there are no previous image, return null. (case 2)
             * @param {Image} image Input image.
             * @returns {Image} The previous image of the input image.
             */
            getPrevImageByImage(image) {
                const idx = this.getImageIdx(image);
                if (idx > 0) {
                    return this.images[idx - 1];
                }
                return null;
            }

            /**
             * Get the next image based on the given annotation.
             * If there are more image, then directly return the next image. (case 1)
             * If there are no more image, return null. (case 2)
             * @param {Annotation} annotaiton Input Annotation
             * @returns {Image} The next image of the input annotation.
             */
            getNextImageByAnnotation(annotaiton) {
                const image = this.getImageByAnnotation(annotaiton);
                return this.getNextImageByImage(image);
            }

            /**
             * Get the previous image based on the given annotation.
             * If there are previous image, then directly return the previous image. (case 1)
             * If there are no previous image, return null. (case 2)
             * @param {Annotation} annotaiton Input Annotation
             * @returns {Image} The previous image of the input annotation.
             */
            getPrevImageByAnnotation(annotaiton) {
                const image = this.getImageByAnnotation(annotaiton);
                return this.getPrevImageByImage(image);
            }

            /**
             * Export the dataset to json format.
             * The json will contain list of images data, list of annotaitons data and list of categories data.
             * @returns {string} The json string.
             */
            exportJson() {
                const images = this.images.map((image) => image.jsonData);
                const annotations = this.images.flatMap((image) =>
                    image.annotations.map((anno) => anno.jsonData)
                );
                return JSON.stringify({
                    images,
                    annotations,
                    categories: this.categoriesData,
                });
            }
        }
        // Singleton dataset
        const DATASET = Dataset.getInstance();

        // Currently displayed annotation
        var currentAnnotation = null;
        
        // Load the json file
        const FILE_INPUT = document.getElementById('file-input');
        FILE_INPUT.addEventListener('change', function(e) {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                DATASET.parseJson(e.target.result);
                currentAnnotation = DATASET.getFirstImage().getFirstAnnotation();
                displayAnnotation(currentAnnotation);
            }
            reader.readAsText(file);
            // Hide the upload file container after loading the json file
            document.getElementById('uploadFileContainer').style.display = 'none';
        });

        function handleTest() {
            test_strings = [
                "abalone Google 0000.jpg",
                "octopus cyanea",
                "abalone 000.jpg",
                "aeolid nudibranchs Aeolid nudibranchs1.jpg",
                "juvenile emperor angelfish juvenile emperor angelfish1.jpg",
            ];

            for (const test_string of test_strings) {
                console.log(Annotation.processCategory(test_string));
            }
        }

        /**
         * Save json file
         */
        function saveJsonFile() {
            this.autoSave();
            /*
            if (currenAnnotation.getLabel() === NOT_LABELLED) {
                this.showDialog("Please label the current annotation before saving the json file.");
                return;
            }
            */
            const json = DATASET.exportJson();
            const blob = new Blob([json], {type: "text/plain;charset=utf-8"});
            saveAs(blob, "result.json");
        }

        /**
         * Display given the anntoattion
         * @param {Annotation} annotation
         */
        function displayAnnotation(annotation) {
            const image = DATASET.getImageByAnnotation(annotation);
            this.displayImage(image);
            
            CATEGORY.value = annotation.getCategory();
            CAPTION.value = annotation.getCaption();
            
            let label = annotation.getLabel();
            this.displayLable(label);
            
            let bbox = annotation.getBbox();
            this.displayBbox(bbox[0], bbox[1], bbox[2], bbox[3]);
            
            let maskIdx = image.getAnnotationIdx(annotation);
            let maskCount = image.getAnnotationsCount();
            this.displayMaskIndex(maskIdx+1, maskCount);

            let imageIdx = DATASET.getImageIdx(image);
            let imageCount = DATASET.getImages().length;
            this.displayImageIndex(imageIdx+1, imageCount);

            let negativeTagsString = annotation.getNegativeTagsString();
            let negativeTags = negativeTagsString.split(",");
            displayNegativeTags(negativeTags);

            let category = annotation.getCategory();
            let categoryCount = getCategoryCount();
            let categoryRefinedCount = getCategoryRefinedCount();
            displayCategoryRefinedCount(categoryRefinedCount[category], categoryCount[category]);
            displayCategoryLabel(category);
        }

        /**
         * Display given image
         * @param {Image} image
         */
        function displayImage(image) {
            IMG.src = image.getPath();
            IMG_NAME.innerText = image.getFileName();
        }
        
        /**
         * Display label
         * @param {number} label
         */
        function displayLable(label) {
            if (label === POSITIVE) {
                RADIO_REFINED.checked = false;
                RADIO_POS.checked = true;
                RADIO_NEG.checked = false;
            } else if (label === NEGATIVE) {
                RADIO_REFINED.checked = false;
                RADIO_POS.checked = false;
                RADIO_NEG.checked = true;
            } else if (label == REFINED) {
                RADIO_REFINED.checked = true;
                RADIO_POS.checked = false;
                RADIO_NEG.checked = false;
            } else {
                RADIO_REFINED.checked = false;
                RADIO_POS.checked = false;
                RADIO_NEG.checked = false;
            }
        }
    

        /**
         * Set annotation to be current anntation
         */
        function setCurrentAnnotation(annotation) {
            this.currenAnnotation = annotation;
        }

        /**
         * Display the bounding box of the annotation
         * @param {number} x The x coordinate of the bounding box.
         * @param {number} y The y coordinate of the bounding box.
         * @param {number} w The width of the bounding box.
         * @param {number} h The height of the bounding box.
         */
        function displayBbox(x, y, w, h) {

            let box_x = x;
            let box_y = y;
            let box_w = w;
            let box_h = h;

            // Get the image and image container dimensions
            const image = DATASET.getImageByAnnotation(currentAnnotation);
            const imageWidth = image.getWidth();
            const imageHeight = image.getHeight();
            const containerWidth = IMG_CONTAINER.clientWidth;
            const containerHeight = IMG_CONTAINER.clientHeight;

            // Calculate the new xywh values based on the dimensions
            const newX = (x / imageWidth) * containerWidth;
            const newY = (y / imageHeight) * containerHeight;
            const newW = (w / imageWidth) * containerWidth;
            const newH = (h / imageHeight) * containerHeight;
            
            // Convert absolute coordinates to percentages
            const newXPercent = (newX / containerWidth) * 100;
            const newYPercent = (newY / containerHeight) * 100;
            const newWPercent = (newW / containerWidth) * 100;
            const newHPercent = (newH / containerHeight) * 100;

            // Set the style of the bounding box using percentages
            BBOX.style.left = newXPercent + "%";
            BBOX.style.top = newYPercent + "%";
            BBOX.style.width = newWPercent + "%";
            BBOX.style.height = newHPercent + "%";
        }

        /**
         * Toggle the display of the bounding box
         */
        function handleToggleBbox() {
            showLabel = !showLabel;
            if (showLabel) {
                BBOX.style.display = "block";
            } else {
                BBOX.style.display = "none";
            }
        }
        
        /**
         * Get the previous mask
         */
        function handlePreviousMask() {
            this.autoSave();
            let prevAnno = DATASET.getPrevAnnotation(currentAnnotation);
            if (prevAnno) {
                currentAnnotation = prevAnno;
                displayAnnotation(currentAnnotation);
            } else {
                this.showDialog("This the first annotation of the first image.");
            }
        }

        /**
         * Get the next mask.
         * If the current annotation is not labeled, then pop up message to remind user to label the annotation. 
         */
        function handleNextMask() {
            this.autoSave();
            if (currentAnnotation.getLabel() === NOT_LABELLED) {
                this.showDialog("Please label the current annotation before moving to the next one.");
                return;
            }
            if (currentAnnotation.getLabel() === NEGATIVE && currentAnnotation.getNegativeTagsString() === "") {
                this.showDialog("Please select the negative tags before moving to the next one.");
                return;
            }
            let nextAnno = DATASET.getNextAnnotation(currentAnnotation);
            if (nextAnno) {
                currentAnnotation = nextAnno;
                displayAnnotation(currentAnnotation);
            } else {
                this.showDialog("This the last annotation of the last image.");
            }
        }

        /**
         * Pop up a dialog to display given message.
         * @param {string} message The message to be displayed.
         */
        function showDialog(message) {
            NOTIFICATION_MESSAGE.innerText = message;
            NOTIFICATION_DIALOG.showModal();
        }  
        
        /**
         * Get the previous image
         */
        function handlePrevious() {
            this.autoSave();
            let prevImage = DATASET.getPrevImage(currentAnnotation);
            if (prevImage) {
                currentAnnotation = prevImage.getFirstAnnotation();
                displayAnnotation(currentAnnotation);
            } else {
                this.showDialog("This the first image.");
            }
        }

        /**
         * Get the next annotation if there are any, if not, then get the next image.
         */
        function handleNext() {
            this.autoSave();
            if (currentAnnotation.getLabel() === NOT_LABELLED) {
                this.showDialog("Please label the current annotation before moving to the next one.");
                return;
            }
            this.handleNextMask();
        }

        function displayMaskIndex(maskIdx, maskCount) {
            MASK_IDX.innerText = `${maskIdx} / ${maskCount}`;
        }

        function displayImageIndex(imageIdx, imageCount) {
            IMAGE_IDX.innerText = `${imageIdx} / ${imageCount}`;
        }

        function displayCategoryRefinedCount(refinedCount, categoryCount) {
            CATEGORY_COUNT_IDX.innerText = `${refinedCount} / ${categoryCount}`;
        }

        function displayCategoryLabel(category) {
            CATEGORY_COUNT_LABEL.innerText = `Category: ${category}`;
        }
        
        function displayNegativeTags(negativeTags) {
            for (const negative_tag of NEGATIVE_TAGS) {
                const negative_tag_checkbox = document.getElementById(negative_tag + "_checkbox");
                negative_tag_checkbox.checked = false;
                for (const input_negative_tag of negativeTags) {
                    if (input_negative_tag === negative_tag) {
                        negative_tag_checkbox.checked = true;
                        break;
                    }
                }
            }
        }

        /**
         * Continue to the first annotation that is not labeled.
         * If there are no unlabeled annotation, then just jump to the last annotation.
         */
        function handleContinue() {
            this.autoSave();
            for (const image of DATASET.getImages()) {
                for (const annotation of image.getAnnotations()) {
                    if (annotation.getLabel() === NOT_LABELLED) {
                        currentAnnotation = annotation;
                        displayAnnotation(currentAnnotation);
                        return;
                    }
                }
            }
            currentAnnotation = DATASET.getLastImage().getLastAnnotation();
            displayAnnotation(currentAnnotation);
            this.showDialog("All annotations are labeled. Please save the json file and continue to next dataset");
        }

        /**
         * Close the dialog
         */
        function closeDialog() {
            NOTIFICATION_DIALOG.close();
        }

        /**
         * Get the input label from the radio button.
         */
        function getLabelFromRadio() {
            if (RADIO_POS.checked) {
                return POSITIVE;
            } else if (RADIO_NEG.checked) {
                return NEGATIVE;
            } else if (RADIO_REFINED.checked) {
                return REFINED;
            } else {
                return NOT_LABELLED;
            }
        }

        /**
         * Get the input label from the radio button.
         */
        function getRefinedFromRadio() {
            return RADIO_REFINED.checked;
        }

        /**
         * Save the current annotation to the dataset.
         * The annotation include the category, caption, and label.
         */
        function autoSave() {
            currentAnnotation.setCaption(CAPTION.value);
            currentAnnotation.setLabel(getLabelFromRadio());

            const negativeTags = getNegativeTagsFromInput();
            const negativeTagsString = negativeTags.join(",");
            currentAnnotation.setNegativeTagsString(negativeTagsString);
        }

        function getNegativeTagsFromInput() {
            let negativeTags = [];
            for (const negative_tag of NEGATIVE_TAGS) {
                const negative_tag_checkbox = document.getElementById(negative_tag + "_checkbox");
                if (negative_tag_checkbox.checked) {
                    negativeTags.push(negative_tag);
                }
            }
            return negativeTags;
        }

        function attachNegativeTagOnClick() {
            const negative_tag_inputs = document.getElementsByClassName("negative_tag_input");
            for (const negative_tag_input of negative_tag_inputs) {
                negative_tag_input.onclick = function() {
                    displayLable(NEGATIVE)
                }
            }
        }

        function clearNegativeTags() {
            const negative_tag_inputs = document.getElementsByClassName("negative_tag_input");
            for (const negative_tag_input of negative_tag_inputs) {
                negative_tag_input.checked = false;
            }
        }

        /**
         * Get the category refined count.
         * The refined count is calculated that, for each image, if one of the annotation is refined, then the image is refined.
         * And the refined count is the number of refined images for each category.
         */
        function getCategoryRefinedCount() {
            let categoryRefinedCount = {};
            for (const image of DATASET.getImages()) {
                for (const annotation of image.getAnnotations()) {
                    if (annotation.getLabel() === REFINED) {
                        let category = annotation.getCategory();
                        if (!categoryRefinedCount.hasOwnProperty(category)) {
                            categoryRefinedCount[category] = 1;
                        } else {
                            categoryRefinedCount[category] += 1;
                        }
                        break;
                    }
                }
            }
            return categoryRefinedCount;
        }

        /**
         * Get the category count.
         * Category count is calculated by counting the number of image that belong to the category.
         */
        function getCategoryCount() {
            let categoryCount = {};
            for (const image of DATASET.getImages()) {
                for (const annotation of image.getAnnotations()) {
                    let category = annotation.getCategory();
                    if (!categoryCount.hasOwnProperty(category)) {
                        categoryCount[category] = 1;
                    } else {
                        categoryCount[category] += 1;
                    }
                    break;
                }
            }
            return categoryCount;
        }
    </script>
</body>
</html>